<?php
/**
 * Cloudrexx
 *
 * @link      http://www.cloudrexx.com
 * @copyright Cloudrexx AG 2007-2015
 *
 * According to our dual licensing model, this program can be used either
 * under the terms of the GNU Affero General Public License, version 3,
 * or under a proprietary license.
 *
 * The texts of the GNU Affero General Public License with an additional
 * permission and of our proprietary license can be found at and
 * in the LICENSE file you have received along with this program.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * "Cloudrexx" is a registered trademark of Cloudrexx AG.
 * The licensing of the program under the AGPLv3 does not imply a
 * trademark license. Therefore any rights, title and interest in
 * our trademarks remain entirely with us.
 */

namespace Cx\Modules\EasyTemp\Model\Repository;

use Doctrine\ORM\EntityRepository;

/**
 * JobRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class JobRepository extends EntityRepository
{
    /**
     * Add criteria to the WHERE clause of the QueryBuilder
     *
     * Includes name/value pairs from the given criteria as either
     *  - exact matches, value as-is,
     *  - pattern matches, as '%value%', or
     *  - numeric comparisons; either '>=value', or '<=value'
     * depending on the name.
     * @return  void
     * @author  Reto Kohli <reto.kohli@comvation.com>
     */
    static protected function addCriteria(\Doctrine\ORM\QueryBuilder $qb,
        $settings, $criteria = null)
    {
        $and = [];
        foreach ($criteria as $name => $value) {
            if ($value === '') {
                continue;
            }
            // The parameter name MUST consist of word characters only
            // (if it does not, sanitize it here).
            $parameter = $name;
            switch ($name) {
                // Match as-is, using equality
                case 'hash':
                case 'plz':
                case 'organisationid':
                case 'deleted':
                    $and[] = $qb->expr()->eq("job.$name", ":$parameter");
                    break;
                // The search term may match in multiple fields
                case 'term':
                    $value = "%$value%";
                    $or = [];
                    if (!empty($settings['jobs_fulltext_firma_active'])) {
                        $or[] = $qb->expr()->like('job.firma', ":$parameter");
                    }
                    if (!empty($settings['jobs_fulltext_titel_active'])) {
                        $or[] = $qb->expr()->like('job.titel', ":$parameter");
                    }
                    if (!empty($settings['jobs_fulltext_vorspann_active'])) {
                        $or[] = $qb->expr()->like('job.vorspann', ":$parameter");
                    }
                    if (!empty($settings['jobs_fulltext_beruf_active'])) {
                        $or[] = $qb->expr()->like('job.beruf', ":$parameter");
                    }
                    if (!empty($settings['jobs_fulltext_text_active'])) {
                        $or[] = $qb->expr()->like('job.text', ":$parameter");
                    }
                    if (!empty($settings['jobs_fulltext_artderarbeit_active'])) {
                        $or[] = $qb->expr()->like('job.artderarbeit', ":$parameter");
                    }
                    $and[] = call_user_func_array(array($qb->expr(), 'orX'), $or);
                    break;
                // Match as %pattern%
                case 'firma':
                case 'titel':
                case 'vorspann':
                case 'beruf':
                case 'text':
                case 'artderarbeit':
                case 'ort':
                case 'region':
                    $value = "%$value%";
                    $and[] = $qb->expr()->like("job.$name", ":$parameter");
                    break;
                // Match using the exact string, but as %pattern%,
                // because there may be multiple such strings present as a
                // comma separated list in the column
                case 'rubrikid':
                case 'position':
                case 'branche':
                case 'anstellungsart':
                case 'sprache':
                case 'sprachekenntnis_kandidat':
                case 'sprachekenntnis_niveau':
                case 'bildungsniveau':
                case 'berufserfahrung':
                case 'berufserfahrung_position':
                    if (!is_array($value)) {
                        $value = array($value);
                    }
                    // Multiple criteria for the same name are joined by (OR).
                    // Note, however, that the view does not currently
                    // support this.
                    $or = [];
                    foreach ($value as $i => $v) {
                        if ($v === '') {
                            continue;
                        }
                        $p = "{$parameter}_{$i}";
                        $or[] = $qb->expr()->like("job.$name", ":$p");
                        $qb->setParameter($p, "%$v%");
                    }
                    if ($or) {
                        $and[] = call_user_func_array(array($qb->expr(), 'orX'), $or);
                    }
                    continue 2;
                // Match multiple criteria for the same name in a set
                // (comma separated list), joined by (OR).
                case 'kategorie':
                    if (!is_array($value)) {
                        $value = preg_split(
                            '/\s*,\s*/', $value, -1, PREG_SPLIT_NO_EMPTY);
                    }
                    $or = [];
                    foreach ($value as $i => $v) {
                        if ($v === '') {
                            continue;
                        }
                        $p = "{$parameter}_{$i}";
                        // Doctrine does not support FIND_IN_SET(),
                        // so either match the single value exactly,
                        // or anywhere in the comma separated list.
                        $or[] = $qb->expr()->eq("job.$name", ":{$p}_0");
                        $qb->setParameter("{$p}_0", "$v"); // Single
                        $or[] = $qb->expr()->like("job.$name", ":{$p}_1");
                        $qb->setParameter("{$p}_1", "$v,%"); // Start
                        $or[] = $qb->expr()->like("job.$name", ":{$p}_2");
                        $qb->setParameter("{$p}_2", "%,$v,%"); // Middle
                        $or[] = $qb->expr()->like("job.$name", ":{$p}_3");
                        $qb->setParameter("{$p}_3", "%,$v"); // End
                    }
                    if ($or) {
                        $and[] = call_user_func_array(array($qb->expr(), 'orX'), $or);
                    }
                    continue 2;
                // Match (numeric) greater than or equal
                case 'anstellungsgrad':
                case 'alter_von':
                    $and[] = $qb->expr()->gte("job.$name", ":$parameter");
                    break;
                // Match (numeric) less than or equal
                case 'anstellungsgrad_bis':
                case 'alter_bis':
                    $and[] = $qb->expr()->lte("job.$name", ":$parameter");
                    break;
                // Ignore any other (unsupported, unknown, or invalid) names
                default:
                    break;
            }
            $qb->setParameter($parameter, $value);
        }
        $qb->add('where',
            call_user_func_array(array($qb->expr(), 'andX'), $and));
    }

    /**
     * Return Jobs matching the given criteria
     *
     * @param   type    $count      The total matching Jobs count, by reference
     * @param   array   $settings   The module settings
     * @param   array   $criteria   The optional filter criteria
     * @param   integer $offset     The optional record offset
     * @param   integer $limit      The optional record limit
     * @param   string  $order      The optional order field name
     * @param   string  $direction  The optional order direction,
     *                              either 'ASC' or 'DESC'.  Defaults to 'ASC'
     * @return  \Doctrine\Common\Collections\ArrayCollection
     *                              The matching Jobs
     * @author  Reto Kohli <reto.kohli@comvation.com>
     */
    public function findByCriteria(&$count, array $settings,
        array $criteria = null, $offset = -1, $limit = -1,
        $order = null, $direction = null)
    {
        $em = $this->getEntityManager();
        $qb = $em->createQueryBuilder()
            ->select('COUNT(job)')
            ->from('\\Cx\\Modules\\EasyTemp\\Model\\Entity\\Job', 'job');
        self::addCriteria($qb, $settings, $criteria);
        $count = $qb->getQuery()->getSingleScalarResult();
        if ($count < 1) {
            return new \Doctrine\Common\Collections\ArrayCollection;
        }
        $qb = $em->createQueryBuilder()
            ->select('job')
            ->from('\\Cx\\Modules\\EasyTemp\\Model\\Entity\\Job', 'job');
        if (!$direction) {
            $direction = 'ASC';
        }
        if ($order) {
            $qb->orderBy('job.' . $order, $direction);
        }
        // Force the ordering to be unambiguous, in cases where
        // - none is specified, or
        // - the given order column contains duplicates.
        // Without this, entries (with identical values) may be listed
        // on multiple pages, while others won't show at all.
        $qb->addOrderBy('job.hash', $direction);
        if ($offset > 0) {
            $qb->setFirstResult($offset);
        }
        if ($limit > 0) {
            $qb->setMaxResults($limit);
        }
        self::addCriteria($qb, $settings, $criteria);
        $jobs = $qb->getQuery()->getResult();
        return $jobs;
    }

}
