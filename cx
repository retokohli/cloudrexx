@GOTO WIN \
2>/dev/null
#!/bin/bash
# vim: syn=sh

# Wrapper for bash 3
if [[ $BASH_VERSION != 4.* ]]; then
    command="cd /root && ./cx --proxy-host-dir='$(pwd -P)' $@"
    # Special case: user wants to start interactive shell to wrapper container
    if [[ "$@" == "env shell --wrapper" ]]; then
        command="cd /root && bash"
    fi

    # Pass everything through our wrapper
    docker run --rm -ti --name clx-win-wrapper -v "$(pwd -P)/":/root -v /var/run/docker.sock:/var/run/docker.sock cloudrexx/ubuntu bash -c "$command"
    exit 0
fi

# current command, sub-command, sub-sub-command, etc.:
COMMANDS=()
# list of arguments, including default values
declare -A ARGUMENTS
# list of arguments set by user:
declare -A FORCED_ARGUMENTS
# list of default environment configs:
declare -A DEFAULT_CONFIG
# this env's config:
declare -A CONFIG
# list of commands which are handled completely within this script:
INTERNAL_COMMANDS=("envs" "env" "debug")
# temp files:
declare -A TEMP_FILES
trap clean_temp_files EXIT
function clean_temp_files {
    for tempfile in "${!TEMP_FILES[@]}"; do
        rm -f "${TEMP_FILES[$tempfile]}"
    done
}

#######################
# Input param cleanup #
#######################

# default values
DEFAULT_CONFIG=(
    ["port"]=80
    ["hostname"]=""
    ["php-version"]=""
    ["db-image"]="mariadb:10.1"
    ["php-image"]="cloudrexx/web:PHP<php-version>-with-mysql"
    ["db-name"]="dev"
    ["db-pass"]="123456"
    ["db-user"]="root"
    ["db-host"]="db"
)
ARGUMENTS=(
    ["port"]=80
    ["ssl-port"]=443
    ["php-image"]="cloudrexx/web:PHP<php-version>-with-mysql"
    ["db-image"]="mariadb:10.1"
    ["source-repo"]="https://github.com/Cloudrexx/cloudrexx.git"
    ["source-branch"]="master"
    ["scripts-repo"]="https://github.com/Cloudrexx/scripts.git"
    ["scripts-branch"]="master"
    ["root-domain"]="lvh.me"
)

# iterate over all arguments to separate commands and arguments
for arg in "$@"
do
    if [[ "$arg" == --* ]]; then
        arg="${arg:2:${#arg}-2}"
        if [[ "$arg" = *=* ]]; then
            IFS='='; read -r key value <<< "$arg"
            ARGUMENTS[$key]=$value
            FORCED_ARGUMENTS[$key]=$value
        else
            ARGUMENTS[$arg]=true
        fi
    else
        COMMANDS+=("$arg")
    fi
done

##################
# "help" command #
##################
function cmd_help {
    case "$1" in
        envs)
            case "$2" in
                up)
                    echo "Starts the multi-vhost environment.

Synopsis:
    ./cx envs up [<options>]

Available options are:
    --certs-dir=<dir>   Directory to get SSL certificates from.
    --ssl-port=<port>   Port for HTTPS connections. Defaults to 443.
    --port=<port>       Port on which the vhosts are available."
                    ;;
                down)
                    echo "Stops the multi-vhost environment.

Synopsis:
    ./cx envs down"
                    ;;
                restart)
                    echo "Restarts the multi-vhost environment.

Synopsis:
    ./cx envs restart"
                    ;;
                status)
                    echo "Shows the status of the multi-vhost environment.

Synopsis:
    ./cx envs status"
                    ;;
                info)
                    echo "Shows the status of all vhosts' containers.

Synopsis:
    ./cx envs info"
                    ;;
                debug)
                    echo "Shows the logs of the nginx proxy.

Synopsis:
    ./cx envs debug"
                    ;;
                list)
                    echo "Shows a list of all attached environments.

Synopsis:
    ./cx envs list [<options>]

Available options are:
    --dir=<directory>   Shows the name of the environment(s) tied to a directory.
    --all               Also lists environments which are not attached to the proxy.
    --real              Shows docker-compose's project name instead of environment's name"
                    ;;
                locate)
                    echo "Shows the working directory of an environment.

Synopsis:
    ./cx envs locate <environment> [<options>]

Available options are:
    --real              Expects environment name to be docker-compose's project name"
                    ;;
                shell)
                    echo "This command opens an interactive shell of the NGINX proxy docker container.

Synopsis
    ./cx envs shell"
                    ;;
                *)
                    echo "This command manages the environment for multiple Cloudrexx installations on one host.

Synopsis
    ./cx envs <subcommand> [<options>]

Available subcommands are:
    up          Starts the docker containers
    down        Stops the docker containers
    restart     Restarts the docker containers
    status      Tells whether the containers are running
    info        Alias for 'status'
    shell       Interactive shell of the proxy container
    debug       Shows NGINX logs
    list        Lists all environments that are up
    locate      Show an environments working directory

For more info about a subcommand type ./cx help envs <subcommand>";
                    ;;
            esac
            ;;
        env)
            case "$2" in
                init)
                    echo "This command (re-)initializes a Cloudrexx installation and its environment.

Basically it does the following:
    - Checks out main source repository
    - Checks out helper scripts repository
    - Generates docker configuration (docker-compose.yml)
    - Starts necessary docker containers
    - Loads database

Synopsis
    ./cx env init [<options>]

Available options are:
    --yes                           Answer all questions with yes. Use with care!
    --silent                        Do not output non-necessary messages
    --scale=<int>                   Sets the number of PHP-Containers to spawn. Useful for testing.
    --skip-source                   Skips GIT clone for source code repository
    --source-repo=<repoUrl>         GIT-URL for the source code repository. Default is https://github.com/Cloudrexx/cloudrexx
    --source-branch=<branchName>    GIT branch to check out of the source code repository. Default is master.
    --skip-scripts                  Skips GIT clone for scripts repository
    --scripts-dir=<dir>             Locale directory to use as scripts directory instead of cloning from GIT repository
    --scripts-repo=<repoUrl>        GIT-URL for the scripts repository. Default is https://github.com/Cloudrexx/scripts
    --scripts-branch=<branchName>   GIT branch to check out of the scripts repository. Default is master.
    --skip-database                 Does not initialize database.

In addition all options of ./cx env config can be used, see ./cx help env config."
                    ;;
                up)
                    echo "This command starts the environment for your installation.

Synopsis
    ./cx env up"
                    ;;
                down)
                    echo "This command stops the environment for your installation.

Synopsis
    ./cx env down [<options>]

Available options are:
    --purge     Drops docker volumes associated with this environment. WARNING: You may loose data!"
                    ;;
                restart)
                    echo "This command restarts the environment for your installation.

Synopsis
    ./cx env restart"
                    ;;
                status)
                    echo "This command shows if the environment for your installation is up and running.

Synopsis
    ./cx env status"
                    ;;
                info)
                    echo "This command shows the status and configuration of the environment for your installation.

Synopsis
    ./cx env info"
                    ;;
                update)
                    echo "This command updates your installation.

Synopsis
    ./cx env update [<options>]

Available options are:
    --yes               Answer all questions with yes. Use with care!
    --silent            Do not output non-necessary messages
    --db                If set without setting --git or --docker only database is updated, implies --force
    --git               If set without setting --db or --docker only GIT is updated
    --docker            If set without setting --db or --git only docker images are updated
    --force             Forces reset of the database even if dump has not changed
    --reset             Resets local GIT clone to origin's state
    --drop-sessions     Skips restoring user sessions
    --drop-users        Skips restoring users, implies --drop-sessions"
                    ;;
                config)
                    echo "This command configures your installation.

Default behavior:
    - If configuration does not yet exist, use default values (or arguments, if set)
    - If configuration exists, only change values in arguments
The option --interactive forces the command to ask for each value

Synopsis
    ./cx env config [<options>]

Available options are:
    --show                          Displays current configuration and exits.
    --yes                           Answer all questions with yes / default. Use with care!
    --silent                        Do not output non-necessary messages
    --interactive                   Ask for each value instead of using default behavior
    --force-default                 Forces default (/automatic) configuration
    --db-host=<hostname>            Sets database host to <hostname>
    --db-name=<dbname>              Sets database name to <dbname>
    --db-user=<username>            Sets database user to <username>
    --db-pass=<password>            Sets database password to <password>
    --php-image=<dockerImageName>   Name of the docker image to use. Default is 'cloudrexx/web:PHP<php_version>-with-mysql'.
    --db-image=<dockerImageName>    Name of the docker image to use. Default is 'mariadb'.
    --php-version=<php-version>     Sets PHP version to <php-version> (example: 7.2), default is based on Cloudrexx version
    --hostname=<hostname>           Sets installation hostname to <hostname>, defaults to parent directory name
    --port=<port>                   Sets installation port to <port>, defaults to 80"
                    ;;
                shell)
                    echo "This command opens an interactive shell of the PHP docker container for this environment.

Synopsis
    ./cx env shell [<options>]

Available options are:
    --root          Opens an interactive root shell on the web container
    --wrapper       Opens an interactive shell of the  Windows wrapper container instead (Windows only)"
                    ;;
                exec)
                    echo "Allows to execute code (Bash/SQL) on containers of this environment.

Synopsis
    ./cx env exec [<options>] <code>

Available options are:
    --root          Execute Bash as root
    --sql           Execute SQL on database container instead of Bash on web container."
                    ;;
                *)
                    echo "This command manages a Cloudrexx installation and its environment.

Synopsis
    ./cx env <subcommand> [<options>]

Available subcommands are:
    init        (Re-)Initializes the environment
    up          Starts the necessary docker containers
    down        Stops the necessary docker containers
    restart     Restarts the necessary docker containers
    status      Checks if all necessary docker containers are running
    info        Calls 'status' and prints environment information
    update      Updates docker images and GIT and reloads database
    config      Configures Cloudrexx (config/configuration.php)
    shell       Interactive shell of the current environment's web container

For more info about a subcommand type ./cx help env <subcommand>";
                    ;;
            esac
            ;;
        help)
            echo "Shows this help"
            ;;
        debug)
            echo "Shows debug output. By default it outputs the last fatal error.

Synopsis
    ./cx debug [<options>]

Available options are:
    --web               Shows the log of the web docker container (Apache)
    --request           Shows the log of the last request
    --clear-usercache   Clears the user cache
    --follow            Follows the log"
            ;;
        *)
            echo "Executes commands for Cloudrexx installations.

Synopsis
    ./cx <command> [<subcommand> [...]] [<cmd_options>] [<cmd_arguments>]

The following commands are available:
    envs        Manages development environments
    env         Manages a development environment
    help        Shows this help
    debug       Returns the last fatal error"
            REGEX="(\S+) - ?(.*)"
            HELP_LIST="$(phpexec | grep $'^\t' 2> /dev/null)"
            spacepad="            "
            while read -r line; do
                [[ "$line" =~ $REGEX ]]
                echo "    ${BASH_REMATCH[1]}${spacepad:${#BASH_REMATCH[1]}}${BASH_REMATCH[2]}"
            done <<< "$HELP_LIST"
            echo "
For more info about a command type ./cx help <command>"
            ;;
    esac
}

##################
# "envs" command #
##################
function cmd_envs {
    case "$1" in
        up)
            if ! isPortFree ${ARGUMENTS["port"]}; then
                if [[ ${ARGUMENTS["silent"]} != true ]]; then
                    echo "TCP port ${ARGUMENTS["port"]} is in use. Stop any service running on this port and try again."
                fi
                exit 1
            fi
            local environments env_dirs
            ARGUMENTS["real"]=true
            ARGUMENTS["all"]=true
            IFS=$'\n'
            set -f
            environments=($(cmd_envs list))
            set +f
            # TODO: Only list environments on the same port
            if [ "${#environments[@]}" -gt "0" ]; then
                if [[ ${ARGUMENTS["yes"]} != true ]]; then
                    echo "The following environments are up. Shall they be adopted?"
                    for environment in "${environments[@]}"; do
                        echo "    $environment"
                    done
                    read -p "Adopt environments? [Yn]? " -n 1 -r
                    echo ""
                fi
                if [[ ${ARGUMENTS["yes"]} ]] || [[ "$REPLY" == "" ]] || [[ "$REPLY" =~ ^[Yy]$ ]]; then
                    for environment in "${environments[@]}"; do
                        env_dirs+=($(cmd_envs locate "$environment"))
                        ARGUMENTS["name"]=$environment
                        cmd_env down
                    done
                else
                    if [[ ${ARGUMENTS["silent"]} != true ]]; then
                        echo "Aborting"
                    fi
                    exit
                fi
            fi
            dockerexec network create "<proxy-network>"
            if [[ "${ARGUMENTS["certs-dir"]}" != "" ]]; then
                dockerexec run --rm --name "<proxy-container>" --net "nginx-proxy" -d -p "${ARGUMENTS["port"]}:80" -p "${ARGUMENTS["ssl-port"]}":443 -v "${ARGUMENTS["certs-dir"]}":/etc/nginx/certs:ro -v /var/run/docker.sock:/tmp/docker.sock:ro jwilder/nginx-proxy
            else
                dockerexec run --rm --name "<proxy-container>" --net "nginx-proxy" -d -p "${ARGUMENTS["port"]}:80" -v /var/run/docker.sock:/tmp/docker.sock:ro jwilder/nginx-proxy
            fi
            for env_dir in "${env_dirs[@]}"; do
                (
                    cd "$env_dir"
                    cmd_env config
                    cmd_env up
                )
            done
            ;;
        down)
            local environments env_dir
            ARGUMENTS["real"]=true
            IFS=$'\n'
            set -f
            environments=($(cmd_envs list))
            set +f
            if [ "${#environments[@]}" -gt "0" ]; then
                if [[ ${ARGUMENTS["yes"]} != true ]]; then
                    echo "The following environments are still up. Shall they be shut down?"
                    for environment in "${environments[@]}"; do
                        echo "    $environment"
                    done
                    read -p "Shut environments down? [Yn]? " -n 1 -r
                    echo ""
                fi
                if [[ ${ARGUMENTS["yes"]} ]] || [[ "$REPLY" == "" ]] || [[ "$REPLY" =~ ^[Yy]$ ]]; then
                    if [ "${#environments[@]}" -eq "1" ]; then
                        ARGUMENTS["real"]=true
                        env_dir=$(cmd_envs locate "${environments[0]}")
                    fi
                    for environment in "${environments[@]}"; do
                        ARGUMENTS["name"]=$environment
                        cmd_env down
                    done
                else
                    if [[ ${ARGUMENTS["silent"]} != true ]]; then
                        echo "Aborting"
                    fi
                    exit
                fi
            fi
            dockerexec stop "<proxy-container>"
            dockerexec network rm "<proxy-network>"
            if [ "${#environments[@]}" -eq "1" ]; then
                if [[ ${ARGUMENTS["yes"]} != true ]]; then
                    echo "Should the environment \"${environments[0]}\" be restarted as a standalone environment?"
                    read -p "Reconfigure and start environment? [Yn]? " -n 1 -r
                    echo ""
                fi
                if [[ ${ARGUMENTS["yes"]} ]] || [[ "$REPLY" == "" ]] || [[ "$REPLY" =~ ^[Yy]$ ]]; then
                    (
                        cd "$env_dir"
                        cmd_env config
                        cmd_env up
                    )
                fi
            fi
            ;;
        restart)
            cmd_envs down
            cmd_envs up
            ;;
        status)
            dockerexec ps -f "name=<proxy-container>"
            ;;
        info)
            dockerexec ps -f "name=<container-prefix>*"
            ;;
        debug)
            dockerexec logs -f "<proxy-container>"
            ;;
        shell)
            dockerexec exec -ti "<proxy-container>" bash
            ;;
        list)
            local containerlist
            if [[ "${ARGUMENTS["dir"]}" != "" ]]; then
                containerlist=$(while read -r container; do if [[ "$(docker inspect "$container" | grep "${ARGUMENTS["dir"]}:")" != "" ]]; then echo "$container"; fi done <<< "$(docker ps --format '{{.Names}}')")
            elif [[ ${ARGUMENTS["all"]} ]]; then
                containerlist=$(dockerexec ps -f "name=<container-prefix>" --format "{{.Names}}" | grep web)
            else
                containerlist=$(dockerexec ps -f "name=<container-prefix>" -f "network=<proxy-network>" --format "{{.Names}}" | grep web)
            fi
            if ! [[ ${ARGUMENTS["real"]} ]]; then
                containerlist="${containerlist//"clxenv"/}"
                containerlist="${containerlist//"${ARGUMENTS["root-domain"]//./}_web_1"/}"
            fi
            containerlist="${containerlist//"_web_1"/}"
            echo "$containerlist"
            ;;
        locate)
            local mountline environment
            environment=$2
            if [[ ${ARGUMENTS["real"]} != true ]]; then
                environment="clxenv$2${ARGUMENTS["root-domain"]//./}"
            fi
            mountline=$(docker inspect "${environment}_web_1" | grep ":/var/www/html:")
            REGEX="\"([^:]+):"
            [[ "$mountline" =~ $REGEX ]]
            echo "${BASH_REMATCH[1]}"
            ;;
        *)
            (>&2 echo "No such subcommand")
            ;;
    esac
}

#################
# "env" command #
#################
function cmd_env {
    case "$1" in
        init)
            if [[ ${ARGUMENTS["yes"]} != true ]]; then
                echo "This will install Cloudrexx in the current directory ($(get_real_pwd))"
                read -p "Continue [Yn]? " -n 1 -r
                echo ""
                if [[ "$REPLY" != "" ]] && ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
                    return
                fi
            fi
            if [[ ${ARGUMENTS["skip-source"]} != true || ${ARGUMENTS["skip-scripts"]} != true ]] && [[ ${ARGUMENTS["silent"]} != true ]]; then
                echo "Checking out source and scripts repository"
            fi
            if [[ ${ARGUMENTS["skip-source"]} != true ]]; then
                # We do not simply clone because ./cx already exists
                git init -q
                git remote add origin "${ARGUMENTS["source-repo"]}"
                if [[ ${ARGUMENTS["silent"]} == true ]]; then
                    git fetch --tags -q
                else
                    git fetch --tags
                fi
                git checkout -t -f "origin/${ARGUMENTS["source-branch"]}"
                # assume ./tmp/* and ./config/* are unchanged
                git ls-files -z tmp/ | xargs -0 git update-index --assume-unchanged
                git ls-files -z config/ | xargs -0 git update-index --assume-unchanged
            fi
            if [[ ${ARGUMENTS["skip-scripts"]} != true ]]; then
                if [[ ${ARGUMENTS["scripts-dir"]} != "" ]]; then
                    ln -s "${ARGUMENTS["scripts-dir"]}" "_meta"
                else
                    if [[ ${ARGUMENTS["silent"]} == true ]]; then
                        git clone -q "${ARGUMENTS["scripts-repo"]}" --branch="${ARGUMENTS["scripts-branch"]}" _meta
                    else
                        git clone "${ARGUMENTS["scripts-repo"]}" --branch="${ARGUMENTS["scripts-branch"]}" _meta
                    fi
                fi
            fi
            if [[ ${ARGUMENTS["silent"]} != true ]]; then
                echo "Configuring the environment"
            fi
            ARGUMENTS["force-default"]=true && cmd_env config
            if [[ ${ARGUMENTS["silent"]} != true ]]; then
                echo "Loading docker containers"
            fi
            local result
            result="$(cmd_env up)"
            if [[ "$?" != "0" ]]; then
                echo "$result"
                echo "In order to retry, please run ./cx env init --skip-scripts --skip-source"
                exit
            fi
            if [[ ${ARGUMENTS["skip-database"]} != true ]]; then
                if [[ ${ARGUMENTS["silent"]} != true ]]; then
                    echo "Loading database"
                fi
                ARGUMENTS["db"]=true && ARGUMENTS["drop-users"]=true && cmd_env update
            fi
            if [[ "${CONFIG["cms-version"]:0:1}" -ge 5 ]]; then
                if [[ ${ARGUMENTS["silent"]} != true ]]; then
                    echo "Configuring cache"
                fi
                phpexec Setting set Config -engine=Yaml -group=cache cacheEnabled on > /dev/null
                phpexec Setting set Config -engine=Yaml -group=cache internalSsiCache on > /dev/null
                phpexec Setting set Config -engine=Yaml -group=cache cacheUserCache memcached > /dev/null
                phpexec Setting set Config -engine=Yaml -group=cache cacheUserCacheMemcacheConfig "{\"ip\":\"usercache\",\"port\":\"11211\"}" > /dev/null
                phpexec Setting set Config -engine=Yaml -group=cache cacheUserCacheMemcachedConfig "{\"ip\":\"usercache\",\"port\":\"11211\"}" > /dev/null
                phpexec Setting set Config -engine=Yaml -group=cache cacheDbStatus on > /dev/null
                phpexec Setting set Config -engine=Yaml -group=cache cacheOPCache zendopcache > /dev/null
                phpexec Setting set Config -engine=Yaml -group=cache cacheOpStatus on > /dev/null
                phpexec Setting set Config -engine=Yaml -group=site forceDomainUrl on > /dev/null
                phpexec Setting set Config -engine=Yaml -group=site forceProtocolFrontend http > /dev/null
                phpexec Setting set Config -engine=Yaml -group=administrationArea forceProtocolBackend http > /dev/null
            fi
            echo "$result"
            ;;
        up)
            get_config_array
            if [[ ${CONFIG["is-vhost"]} != true ]]; then
                if ! isPortFree "${CONFIG["port"]}"; then
                    if [[ ${ARGUMENTS["silent"]} != true ]]; then
                        echo "TCP port ${CONFIG["port"]} is in use. Stop any service running on this port and try again."
                    fi
                    exit 1
                fi
            fi
            if [[ ${ARGUMENTS["silent"]} != true ]]; then
                dockercomposeexec up -d
                echo "Waiting for database server to come up..."
            else
                dockercomposeexec up -d &> /dev/null
            fi
            dockerexec exec "<db-container>" bash -c "while ! echo | mysql -u${CONFIG["db-user"]} -p${CONFIG["db-pass"]} &> /dev/null; do sleep 1; done"
            if [[ ${ARGUMENTS["silent"]} != true ]]; then
                echo "Applying configuration to new environment"
            fi
            phpexec config --force
            if [[ ${ARGUMENTS["silent"]} != true ]]; then
                echo "Environment successfully initialized. It is available at http://${CONFIG["hostname"]}/"
                if [[ ${CONFIG["is-vhost"]} == true ]]; then
                    echo "phpMyAdmin is available at http://phpma.${CONFIG["hostname"]}/"
                else
                    echo "phpMyAdmin is available at http://${CONFIG["hostname"]}:8234/"
                fi
            fi
            exit 0
            ;;
        down)
            local environments
            if [[ "${ARGUMENTS["name"]}" != "" ]]; then
                environments=(${ARGUMENTS["name"]})
            else
                ARGUMENTS["dir"]="$(get_real_pwd)"
                ARGUMENTS["real"]=true
                IFS=$'\n'
                set -f
                environments=($(cmd_envs list))
                set +f
            fi
            get_config_array
            environments+=("clxenv${CONFIG["hostname"]//./}")
            environments=($(tr ' ' '\n' <<< "${environments[@]}" | sort -u | tr '\n' ' '))
            for environment in "${environments[@]}"; do
                echo "Shutting down environment clxenv$environment"
                if [[ "${ARGUMENTS["purge"]}" == true ]]; then
                    docker-compose --project-name "$environment" down -v
                else
                    docker-compose --project-name "$environment" down
                fi
            done
            ;;
        restart)
            cmd_env down
            cmd_env up
            ;;
        status)
            if [[ ${ARGUMENTS["q"]} == true ]]; then
                echo "" | dockercomposeexec ps -q > /dev/null
                exit $?
            else
                dockercomposeexec ps
            fi
            ;;
        info)
            cmd_env status
            ARGUMENTS["show"]=true && cmd_env config
            ;;
        update)
            if [[ ${ARGUMENTS["db"]} != true && ${ARGUMENTS["git"]} != true ]] || [[ ${ARGUMENTS["docker"]} = true ]]; then
                dockercomposeexec pull
            fi
            STRUCTMD5=$(/usr/bin/md5sum installer/data/contrexx_dump_structure.sql)
            DATAMD5=$(/usr/bin/md5sum installer/data/contrexx_dump_data.sql)
            DB_UPDATE_NECESSARY=false
            get_config_array
            if [[ ${ARGUMENTS["db"]} != true && ${ARGUMENTS["docker"]} != true ]] || [[ ${ARGUMENTS["git"]} = true ]]; then
                if [[ ${ARGUMENTS["reset"]} == true ]]; then
                    if [[ ${ARGUMENTS["yes"]} != true ]]; then
                        echo "This will remove all local changes. Are you sure?"
                        read -p "Continue [Ny]? " -n 1 -r
                        echo ""
                        if ! [[ "$REPLY" =~ ^[Yy]$ ]]; then
                            return
                        fi
                    fi
                    git fetch
                    git reset --hard
                    git clean -ffdx
                    set_config_array
                else
                    git stash
                    git pull
                    git stash pop
                fi
                STRUCTMD5NEW=$(/usr/bin/md5sum installer/data/contrexx_dump_structure.sql)
                DATAMD5NEW=$(/usr/bin/md5sum installer/data/contrexx_dump_data.sql)
                if [[ "$STRUCTMD5NEW" != "$STRUCTMD5" || "$DATAMD5NEW" != "$DATAMD5" ]]; then
                    DB_UPDATE_NECESSARY=true
                else
                    DB_UPDATE_NECESSARY=false
                fi
            fi
            if [[ ${ARGUMENTS["git"]} = true || ${ARGUMENTS["docker"]} = true ]] && [[ ${ARGUMENTS["db"]} != true ]]; then
                if [[ $DB_UPDATE_NECESSARY = true && ${ARGUMENTS["silent"]} != true ]]; then
                    echo "DB update would be necessary, you may want to run ./cx env update --db"
                fi
                return
            fi
            if [[ ${ARGUMENTS["force"]} != true && ${ARGUMENTS["db"]} != true && $DB_UPDATE_NECESSARY != true && ${ARGUMENTS["silent"]} != true ]]; then
                echo "DB update not necessary, run ./cx env update --db --force if you want to force db reload"
                return
            fi

            # create login file
            mysql_create_tempfile

            if [[ ${ARGUMENTS["drop-users"]} != true ]]; then
                TEMP_FILES["user-backup"]="$(mktemp)"
                mysql_dump --no-create-info --skip-triggers "${CONFIG["db-name"]}" contrexx_access_users contrexx_access_user_profile > "${TEMP_FILES["user-backup"]}"
                mysql_dump --no-create-info --skip-triggers -w 'attribute_id=0' "${CONFIG["db-name"]}" contrexx_access_user_attribute_value >> "${TEMP_FILES["user-backup"]}"
                if [[ ${ARGUMENTS["drop-sessions"]} != true ]]; then
                    TEMP_FILES["session-backup"]="$(mktemp)"
                    mysql_dump --no-create-info --skip-triggers "${CONFIG["db-name"]}" contrexx_sessions > "${TEMP_FILES["session-backup"]}"
                fi
            fi
            # empty database if exists
# from https://stackoverflow.com/questions/12403662/how-to-remove-all-mysql-tables-from-the-command-line-without-drop-database-permi
            mysql_exec "
SET FOREIGN_KEY_CHECKS = 0;
SET GROUP_CONCAT_MAX_LEN=32768;
SET @tables = NULL;
SELECT GROUP_CONCAT('\`', table_name, '\`') INTO @tables
      FROM information_schema.tables
        WHERE table_schema = (SELECT DATABASE()) AND table_name LIKE '${CONFIG["db-prefix"]}%';
SELECT IFNULL(@tables,'dummy') INTO @tables;

SET @tables = CONCAT('DROP TABLE IF EXISTS ', @tables);
PREPARE stmt FROM @tables;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
SET @views = NULL;
SELECT GROUP_CONCAT('\`', TABLE_NAME, '\`') INTO @views
      FROM information_schema.views
        WHERE table_schema = (SELECT DATABASE()) AND table_name LIKE '${CONFIG["db-prefix"]}%';
SELECT IFNULL(@views,'dummy') INTO @views;

SET @views = CONCAT('DROP VIEW IF EXISTS ', @views);
PREPARE stmt FROM @views;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
SET FOREIGN_KEY_CHECKS = 1;"
            # create db if it does not exist
            mysql_exec "CREATE DATABASE IF NOT EXISTS ${CONFIG["db-name"]} COLLATE utf8_unicode_ci"
            # load db
            mysql_load "installer/data/contrexx_dump_structure.sql"
            mysql_load "installer/data/contrexx_dump_data.sql"
            if [[ ${ARGUMENTS["drop-users"]} != true ]]; then
                mysql_load "${TEMP_FILES["user-backup"]}"
                if [[ ${ARGUMENTS["drop-sessions"]} != true ]]; then
                    mysql_load "${TEMP_FILES["session-backup"]}"
                fi
            fi
            # TODO: Check if there's at least one admin, make the user's ID dynamic
            EXISTING_CX_USER=$(mysql_exec "SELECT id FROM contrexx_access_users WHERE id = 1")
            if [[ "$EXISTING_CX_USER" == "" ]]; then
                if [[ ${ARGUMENTS["yes"]} != true ]]; then
                    echo "There is no user, will create a default user. Ok?"
                    read -p "Continue [Yn]? " -n 1 -r
                    echo ""
                    if [[ "$REPLY" =~ ^[Nn]$ ]]; then
                        mysql_drop_tempfile
                        return
                    fi
                fi
                # there is no user and we decided to create one
                declare -A ClxCredentials
                ClxCredentials["user"]=""
                ClxCredentials["mail"]="info@example.org"
                ClxCredentials["pass"]="123456"
                if [[ ${ARGUMENTS["yes"]} != true ]]; then
                    for key in "${!ClxCredentials[@]}"; do
                        read -r -p "Enter Cloudrexx $key [${ClxCredentials[$key]}]: " newvalue
                        if [[ "$newvalue" != "" ]]; then
                            ClxCredentials[$key]="$newvalue"
                        fi
                    done
                fi
                mysql_exec "INSERT INTO contrexx_access_users (id, is_admin, username, password, regdate, expiration, validity, last_auth, last_activity, email, email_access, frontend_lang_id, backend_lang_id, active, profile_access, restore_key, restore_key_time, u2u_active, auth_token) VALUES (1,1,'${ClxCredentials["user"]}',MD5('${ClxCredentials["pass"]}'),0,0,0,0,0,'${ClxCredentials["mail"]}','nobody', 0,0,1,'members_only','',0,'0', '');INSERT INTO contrexx_access_user_profile (user_id, gender, title, firstname, lastname, company, address, city, zip, country, phone_office, phone_private, phone_mobile, phone_fax, birthday, website, profession, interests, signature, picture) VALUES (1,'gender_undefined',2,'CMS','System Benutzer','','','','',0,'','','','','','','','','','');"
                if [[ ${ARGUMENTS["silent"]} != true ]]; then
                    echo "Created the user \"${ClxCredentials["user"]}\" with e-mail \"${ClxCredentials["mail"]}\" and password \"${ClxCredentials["pass"]}\""
                fi
            fi
            mysql_drop_tempfile
            ;;
        config)
            if [[ ${ARGUMENTS["show"]} = true ]]; then
                echo -e "Key\t\tValue"
                echo "========================"
                get_config_array
                for value in "${!CONFIG[@]}"; do
                    echo -e "$value\t\t${CONFIG[$value]}"
                done
                return
            fi
            get_config_array
            declare -A CONFIG_OVERRIDE
            if [ ${#CONFIG[@]} -eq 0 ] || [[ ${ARGUMENTS["force-default"]} == true ]] ; then
                # load config, if its empty: load default config over it
                for value in "${!ARGUMENTS[@]}"; do
                    CONFIG_OVERRIDE[$value]=${ARGUMENTS[$value]}
                done
            fi
            # load forced arguments over it
            for value in "${!FORCED_ARGUMENTS[@]}"; do
                CONFIG_OVERRIDE[$value]=${FORCED_ARGUMENTS[$value]}
            done
            # loop over CONFIG_OVERRIDE and override all 
            for value in "${!CONFIG_OVERRIDE[@]}"; do
                CONFIG[$value]=${CONFIG_OVERRIDE[$value]}
            done
            # if interactive: loop over all options and let the user decide
            if [[ ${ARGUMENTS["interactive"]} = true ]]; then
                # TODO: Only ask if argument is not in forced arguments
                for value in "${!DEFAULT_CONFIG[@]}"; do
                    read -r -p "Enter value for '$value' [${CONFIG[$value]}]: " newvalue
                    if [[ "$newvalue" != "" ]]; then
                        CONFIG[$value]=$newvalue
                    fi
                done
            fi
            set_config_array
            ;;
        shell)
            if [[ ${ARGUMENTS["root"]} ]]; then
                dockerexec exec -ti "<web-container>" bash
            else
                dockerexec exec -ti --user www-data "<web-container>" bash
            fi
            ;;
        exec)
            shift
            if read -r -t 0; then
                input=$(cat -)
            fi
            if [[ ${ARGUMENTS["sql"]} ]]; then
                get_config_array
                mysql_create_tempfile
                if read -r -t 0; then
                    mysql_exec "$input"
                else
                    mysql_exec "$@"
                fi
                mysql_drop_tempfile
            else
                if read -r -t 0; then
                    get_config_array
                    if [[ ${ARGUMENTS["root"]} ]]; then
                        echo "$input" | internal_dockerexec exec -i "<web-container>" bash -c "$@"
                    else
                        echo "$input" | internal_dockerexec exec -i --user www-data "<web-container>" bash -c "$@"
                    fi
                else
                    if [[ ${ARGUMENTS["root"]} ]]; then
                        dockerexec exec -ti "<web-container>" bash -c "$@"
                    else
                        dockerexec exec -ti --user www-data "<web-container>" bash -c "$@"
                    fi
                fi
            fi
            ;;
        *)
            (>&2 echo "No such subcommand")
            ;;
    esac
}

function get_config_array {
    local CONFIG_FILE="config/configuration.php"
    local SETTINGS_FILE="config/settings.php"
    local COMPOSE_FILE="docker-compose.yml"
    if ! [[ -f $CONFIG_FILE ]] || ! [[ -f $SETTINGS_FILE ]]; then
        CONFIG=()
        return
    fi
    CONFIG=(
        ["db-host"]=""
        ["db-name"]=""
        ["db-user"]=""
        ["db-pass"]=""
        ["db-prefix"]=""
        ["hostname"]=""
        ["cms-version"]=$(REGEX="CONFIG\['coreCmsVersion'\]\ +=\ +(['\"])([^'\"]+)\1;"; CFG=$(cat $SETTINGS_FILE); [[ "$CFG" =~ $REGEX ]] && echo "${BASH_REMATCH[2]}")
        ["port"]=""
        ["php-version"]=""
        ["php-image"]=""
        ["db-image"]=""
        ["is-vhost"]=""
    )
    if [[ ${ARGUMENTS["force-default"]} != true ]]; then
        CONFIG["db-host"]=$(REGEX="DBCONFIG\['host'\]\ +=\ +(['\"])([^'\"]+)\1;"; CFG=$(cat $CONFIG_FILE); [[ "$CFG" =~ $REGEX ]] && echo "${BASH_REMATCH[2]}")
        CONFIG["db-name"]=$(REGEX="DBCONFIG\['database'\]\ +=\ +(['\"])([^'\"]+)\1;"; CFG=$(cat $CONFIG_FILE); [[ "$CFG" =~ $REGEX ]] && echo "${BASH_REMATCH[2]}")
        CONFIG["db-user"]=$(REGEX="DBCONFIG\['user'\]\ +=\ +(['\"])([^'\"]+)\1;"; CFG=$(cat $CONFIG_FILE); [[ "$CFG" =~ $REGEX ]] && echo "${BASH_REMATCH[2]}")
        CONFIG["db-pass"]=$(REGEX="DBCONFIG\['password'\]\ +=\ +(['\"])([^'\"]+)\1;"; CFG=$(cat $CONFIG_FILE); [[ "$CFG" =~ $REGEX ]] && echo "${BASH_REMATCH[2]}")
        CONFIG["db-prefix"]=$(REGEX="DBCONFIG\['tablePrefix'\]\ +=\ +(['\"])([^'\"]+)\1;"; CFG=$(cat $CONFIG_FILE); [[ "$CFG" =~ $REGEX ]] && echo "${BASH_REMATCH[2]}")
        CONFIG["hostname"]=$(REGEX="CONFIG\['domainUrl'\]\ +=\ +(['\"])([^'\"]+)\1;"; CFG=$(cat $SETTINGS_FILE); [[ "$CFG" =~ $REGEX ]] && echo "${BASH_REMATCH[2]}")
        CONFIG["port"]=$(REGEX="CONFIG\['portFrontendHTTP'\]\ +=\ +([0-9]+);"; CFG=$(cat $SETTINGS_FILE); [[ "$CFG" =~ $REGEX ]] && echo "${BASH_REMATCH[1]}")
    fi

    local proxy_present
    proxy_present=$(internal_dockerexec ps -q -f "name=<proxy-container>")
    if [[ "$proxy_present" == "" ]]; then
        CONFIG["is-vhost"]=false
    else
        CONFIG["is-vhost"]=true
    fi
    if [ -f "docker-compose.yml" ]; then
        CONFIG["db-image"]=$(REGEX="db:\s*image: \"([^\"]+)\""; CFG=$(cat $COMPOSE_FILE); [[ "$CFG" =~ $REGEX ]] && echo "${BASH_REMATCH[1]}")
        CONFIG["php-image"]=$(REGEX="web:\s*image: \"([^\"]+)\""; CFG=$(cat $COMPOSE_FILE); [[ "$CFG" =~ $REGEX ]] && echo "${BASH_REMATCH[1]}")
        CONFIG["php-version"]=$(REGEX="([0-9]+\.[0-9]+)"; [[ "${CONFIG["php-image"]}" =~ $REGEX ]] && echo "${BASH_REMATCH[1]}")
        if [[ "${CONFIG["php-version"]}" != "" ]]; then
            CONFIG["php-image"]=${CONFIG[php-image]//"${CONFIG["php-version"]}"/"<php-version>"}
        fi
        if [[ "$(cat $COMPOSE_FILE)" =~ "VIRTUAL_HOST" ]]; then
            CONFIG["is-vhost"]=true
        else
            CONFIG["is-vhost"]=false
        fi
    fi
    if [[ "${CONFIG["hostname"]}" == "" || "${CONFIG["hostname"]}" == "localhost" ]]; then
        local working_directory
        working_directory=$(get_real_pwd)
        working_directory=${working_directory//" "/""}
        working_directory=${working_directory//"_"/""}
        working_directory=${working_directory,,}
        CONFIG["hostname"]="${working_directory##*/}.${ARGUMENTS["root-domain"]}"
    fi
    if [[ "${CONFIG["php-version"]}" == "" ]]; then
        CONFIG["php-version"]="5.6"
        if [[ "${CONFIG["cms-version"]:0:1}" -ge 5 ]]; then
            CONFIG["php-version"]="7.0"
        elif [[ "${CONFIG["cms-version"]:0:1}" -lt 3 ]]; then
            CONFIG["php-version"]="5.3"
        fi
    fi
    if [[ "${CONFIG["port"]}" == "" ]]; then
        CONFIG["port"]=${DEFAULT_CONFIG["port"]}
    fi
    if [[ "${CONFIG["php-image"]}" == "" ]]; then
        CONFIG["php-image"]=${DEFAULT_CONFIG["php-image"]}
    fi
    if [[ "${CONFIG["db-image"]}" == "" ]]; then
        if [[ "${CONFIG["cms-version"]:0:1}" -ge 5 ]]; then
            CONFIG["db-image"]=${DEFAULT_CONFIG["db-image"]}
        else
            CONFIG["db-image"]="mariadb:5"
        fi
    fi
    if [[ "${CONFIG["db-host"]}" == "" ]]; then
        CONFIG["db-host"]=${DEFAULT_CONFIG["db-host"]}
    fi
    if [[ "${CONFIG["db-name"]}" == "" ]]; then
        CONFIG["db-name"]=${DEFAULT_CONFIG["db-name"]}
    fi
    if [[ "${CONFIG["db-user"]}" == "" ]]; then
        CONFIG["db-user"]=${DEFAULT_CONFIG["db-user"]}
        if [[ "${CONFIG["db-pass"]}" == "" ]]; then
            CONFIG["db-pass"]=${DEFAULT_CONFIG["db-pass"]}
        fi
    fi
}

function set_config_array {
    local proxy_present
    proxy_present=$(internal_dockerexec ps -q -f "name=<proxy-container>")
    if [[ "$proxy_present" == "" ]]; then
        CONFIG["is-vhost"]=false
    else
        CONFIG["is-vhost"]=true
    fi

    # load config file
    FILE_CONTENTS=$(cat config/configuration.php)
    # replace db-host, db-name, db-user, db-pass
    FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "((DBCONFIG\['host'\]\ +=\ +['\"])[^'\"]*(['\"];))" "${CONFIG["db-host"]}")
    FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "((DBCONFIG\['database'\]\ +=\ +['\"])[^'\"]*(['\"];))" "${CONFIG["db-name"]}")
    FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "((DBCONFIG\['user'\]\ +=\ +['\"])[^'\"]*(['\"];))" "${CONFIG["db-user"]}")
    FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "((DBCONFIG\['password'\]\ +=\ +['\"])[^'\"]*(['\"];))" "${CONFIG["db-pass"]}")
    FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "((define\('CONTREXX_INSTALLED', )false(\);))" "true")
    FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "((define\('CONTEXX_INSTALLED', )false(\);))" "true")
    if [[ "${CONFIG["cms-version"]:0:1}" == "3" && "${CONFIG["cms-version"]:2:1}" == "0" ]] || [[ "${CONFIG["cms-version"]:0:1}" -lt 3 ]]; then
        FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "((PATHCONFIG\['ascms_root'\]\ +=\ +['\"])[^'\"]*(['\"];))" "/var/www/html")
        FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "((PATHCONFIG\['ascms_root_offset'\]\ +=\ +['\"])[^'\"]*(['\"];))" "")
    fi
    # save config file
    echo "$FILE_CONTENTS" > config/configuration.php

    # load settings
    FILE_CONTENTS=$(cat config/settings.php)
    # replace hostname, port
    FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "((CONFIG\['portFrontendHTTP'\]\ +=\ +)[0-9]+(;))" "${CONFIG["port"]}")
    FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "((CONFIG\['domainUrl'\]\ +=\ +['\"])[^'\"]*(['\"];))" "${CONFIG["hostname"]}")
    # save settings
    echo "$FILE_CONTENTS" > config/settings.php

    # set correct rewritebase
    FILE_CONTENTS=$(cat .htaccess)
    FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "((RewriteBase\s+/)[-_a-zA-Z0-9/]*())" "")
    echo "$FILE_CONTENTS" > .htaccess

    # load _meta/docker-compose.yml
    FILE_CONTENTS=$(cat _meta/docker-compose.tpl)
    # replace php-image with php-version internally
    PHP_IMAGE=${CONFIG["php-image"]}
    PHP_IMAGE=${PHP_IMAGE//"<php-version>"/${CONFIG["php-version"]}}
    # replace hostname, php- and db-image
    local working_directory
    working_directory="."
    if runs_as_proxy; then
        working_directory="$(get_real_pwd)"
    fi
    FILE_CONTENTS=${FILE_CONTENTS//"<cd>"/"$working_directory"}
    FILE_CONTENTS=${FILE_CONTENTS//"<hostname>"/${CONFIG["hostname"]}}
    FILE_CONTENTS=${FILE_CONTENTS//"<php-image>"/$PHP_IMAGE}
    FILE_CONTENTS=${FILE_CONTENTS//"<db-image>"/${CONFIG["db-image"]}}
    FILE_CONTENTS=${FILE_CONTENTS//"<proxy-network>"/"nginx-proxy"}
    FILE_CONTENTS=${FILE_CONTENTS//"<port>"/${CONFIG["port"]}}
    # TODO: Find better way to replace all occurences
    if [[ "${CONFIG["is-vhost"]}" == true ]]; then
        FILE_CONTENTS=${FILE_CONTENTS//"<vhost>"/""}
        FILE_CONTENTS=${FILE_CONTENTS//"</vhost>"/""}
        FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "(()<novhost>[^<]*</novhost>())" "")
        FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "(()<novhost>[^<]*</novhost>())" "")
        FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "(()<novhost>[^<]*</novhost>())" "")
    else
        FILE_CONTENTS=${FILE_CONTENTS//"<novhost>"/""}
        FILE_CONTENTS=${FILE_CONTENTS//"</novhost>"/""}
        FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "(()<vhost>[^<]*</vhost>())" "")
        FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "(()<vhost>[^<]*</vhost>())" "")
        FILE_CONTENTS=$(regex_replace "$FILE_CONTENTS" "(()<vhost>[^<]*</vhost>())" "")
    fi
    # save docker-compose.yml
    echo "$FILE_CONTENTS" > docker-compose.yml
    
    if [[ "${CONFIG["cms-version"]:0:1}" -ge 5 ]] && [ "$(dockerexec ps -q -f "name=<web-container>")" ]; then
        if [[ ${ARGUMENTS["silent"]} != true ]]; then
            echo "Applying configuration to running environment"
        fi
        phpexec config --force
    fi
}

#####################
# Wrapper functions #
#####################
function phpexec {
    # TODO: Check if we should run async
    if type docker >/dev/null 2>&1; then
        if [ ! "$(dockerexec ps -q -f "name=<web-container>")" ]; then
            if type php >/dev/null 2>&1; then
                php index.php "$@"
            else
                echo "Environment not running!"
            fi
        else
            dockerexec exec -ti --user www-data "<web-container>" php index.php "$@"
        fi
    else
        php index.php "$@"
    fi
}

function dockerexec {
    get_config_array
    internal_dockerexec "$@"
}

function internal_dockerexec {
    local ENV_NAME="${CONFIG[hostname]//"."/}"
    local ARGS=()
    for index in "$@"; do
        index="${index//"<web-container>"/"<container-prefix><env-name>_web_1"}"
        index="${index//"<db-container>"/"<container-prefix><env-name>_db_1"}"
        index="${index//"<cache-container>"/"<container-prefix><env-name>_usercache_1"}"
        index="${index//"<phpma-container>"/"<container-prefix><env-name>_phpmyadmin_1"}"
        index="${index//"<proxy-container>"/"<proxy-prefix>-proxy"}"
        index="${index//"<container-prefix>"/"clxenv"}"
        index="${index//"<proxy-prefix>"/"clxenvs"}"
        index="${index//"<proxy-network>"/"nginx-proxy"}"
        index="${index//"<env-name>"/"$ENV_NAME"}"
        ARGS+=("$index")
    done
    if read -r -t 0; then
        cat /dev/stdin | docker "${ARGS[@]}"
    else
        docker "${ARGS[@]}"
    fi
}

function dockercomposeexec {
    get_config_array
    docker-compose --project-name "clxenv${CONFIG["hostname"]//./}" "$@"
}

# Returns 1 for docker, 0 for local, 2 for non-running docker
function mysql_is_local {
    if [ "$(dockerexec ps -q -f "name=<web-container>")" ]; then
        return 1
    else
        if type mysql >/dev/null 2>&1; then
            return 0
        fi
        return 2
    fi
}

function mysql_create_tempfile {
    if mysql_is_local; then
        TEMP_FILES["db-connection"]="$(mktemp)"
        echo "[mysql]
default-character-set=utf8
database=${CONFIG["db-name"]}
[client]
host=${CONFIG["db-host"]}
user=${CONFIG["db-user"]}
password=${CONFIG["db-pass"]}" > "${TEMP_FILES["db-connection"]}"
    else
        # TODO: Make trap delete files in container
        TEMP_FILES["db-connection"]=$(dockerexec exec "<db-container>" mktemp)
        echo "[mysql]
default-character-set=utf8
database=${CONFIG["db-name"]}
[client]
host=${CONFIG["db-host"]}
user=${CONFIG["db-user"]}
password=${CONFIG["db-pass"]}" | internal_dockerexec exec -i "<db-container>" bash -c "cat > ${TEMP_FILES["db-connection"]}"
    fi
}

function mysql_dump {
    if mysql_is_local; then
        mysqldump --defaults-file="${TEMP_FILES["db-connection"]}" "$@"
    else
        dockerexec exec "<db-container>" mysqldump --defaults-file="${TEMP_FILES["db-connection"]}" "$@"
    fi
}

function mysql_exec {
    if mysql_is_local; then
        mysql --defaults-file="${TEMP_FILES["db-connection"]}" -A -e "$1"
    else
        echo "$1" | internal_dockerexec exec -i "<db-container>" bash -c "cat - | mysql --defaults-file=${TEMP_FILES["db-connection"]} -A"
    fi
}

function mysql_load {
    if mysql_is_local; then
        cat "$1" | mysql --defaults-file="${TEMP_FILES["db-connection"]}" -A
    else
        cat "$1" | internal_dockerexec exec -i "<db-container>" bash -c "cat - | mysql --defaults-file=${TEMP_FILES["db-connection"]} -A"
    fi
}

function mysql_drop_tempfile {
    if [ "$(dockerexec ps -q -f "name=<web-container>")" ]; then
        dockerexec exec "<db-container>" rm "${TEMP_FILES["db-connection"]}"
        unset TEMP_FILES["db-connection"]
    fi
}

####################
# Helper functions #
####################

# regex_replace <haystack> <regex> <replacement>
# Matches multi-line and replaces only first occurences (/non-global)
# regex match 1 needs to be whole match
# regex match 2 needs to be everything before replaced part
# regex match 3 needs to be everything after replaced part
function regex_replace {
    local HAYSTACK="$1"
    local REGEX="$2"
    local REPLACEMENT="$3"
    [[ "$HAYSTACK" =~ $REGEX ]]
    REPLACE="${BASH_REMATCH[2]}${REPLACEMENT}${BASH_REMATCH[3]}"
    HAYSTACK="${HAYSTACK//"${BASH_REMATCH[0]}"/"$REPLACE"}"
    echo "$HAYSTACK"
}

# Usage: if runs_as_proxy; then
function runs_as_proxy {
    if [[ "$PROXY_HOST_DIR" != "" ]]; then
        return 0
    elif [[ "${ARGUMENTS["proxy-host-dir"]}" != "" ]]; then
        return 0
    else
        return 1
    fi
}

function get_real_pwd {
    local working_directory
    working_directory="$PWD"
    if [[ "$PROXY_HOST_DIR" != "" ]]; then
        working_directory="$PROXY_HOST_DIR"
    elif [[ "${ARGUMENTS["proxy-host-dir"]}" != "" ]]; then
        working_directory="${ARGUMENTS["proxy-host-dir"]}"
    fi
    echo $working_directory
}

# Usage: if isPortFree 123; then
function isPortFree {
    local hostname
    hostname="localhost"
    if runs_as_proxy; then
        local route
        route=($(grep -E "eth0\s*00000000" < /proc/net/route))
        hostname="$((16#${route[2]:6:2})).$((16#${route[2]:4:2})).$((16#${route[2]:2:2})).$((16#${route[2]:0:2}))"
    fi
    if (echo >"/dev/tcp/$hostname/$1") &>/dev/null; then
        return 1
    else
        return 0
    fi
}

#####################
# Decide what to do #
#####################

case "${COMMANDS[0]}" in
    envs)
        COMMANDS=("${COMMANDS[@]:1}")
        cmd_envs "${COMMANDS[@]/#/}"
        ;;
    env)
        COMMANDS=("${COMMANDS[@]:1}")
        if read -r -t 0; then
            cat /dev/stdin | cmd_env "${COMMANDS[@]/#/}"
        else
            cmd_env "${COMMANDS[@]/#/}"
        fi
        ;;
    debug)
        if [[ ${ARGUMENTS["web"]} == true ]]; then
            dockerexec logs -f "<web-container>"
            exit
        elif [[ ${ARGUMENTS["request"]} ]]; then
            requestId=$(tac tmp/log/dbg.log | grep '^[^ ].*"([a-z0-9]\+)" ' -m1 | grep -o ' "([0-9a-z]\+)" ')
            grep -Poz ".*\"\(${requestId:3:12}\)\"(.+)([\n] .*)*[\n]" tmp/log/dbg.log | tr -d '\000'
            exit
        elif [[ ${ARGUMENTS["follow"]} ]]; then
            tail -f -n0 tmp/log/dbg.log
            exit
        elif [[ ${ARGUMENTS["clear-usercache"]} ]]; then
            dockerexec exec "<web-container>" bash -c 'exec 3<>/dev/tcp/usercache/11211 && echo flush_all >&3 && read -u 3 msg_in && echo $msg_in'
            exit
        fi
        tac tmp/log/dbg.log | grep -m1 -B1 "initialization failed" | tac
        ;;
    *)
        if [[ "${COMMANDS[0]}" == "" || "${COMMANDS[0]}" == "help" ]]; then
            # wrapper for "help" command to deliver help for internal commands
            if [[ "${COMMANDS[1]}" == "" || " ${INTERNAL_COMMANDS[@]} " =~ " ${COMMANDS[1]} " ]]; then
                COMMANDS=("${COMMANDS[@]:1}")
                cmd_help "${COMMANDS[@]/#/}"
            else
                shift
                phpexec help "$@"
            fi
        else
            # if system looks installed
            if [ -f "index.php" ]; then
                # TODO: add help text if return value indicates a setup problem (db conn., .htaccess, ...)
                phpexec "$@"
            else
                echo "Cloudrexx does not seem to be installed. Did you already execute the \"env init\" command?"
                cmd_help "${COMMANDS[1]}"
            fi
        fi
        ;;
esac

#########################################
# End of nice part, lesser systems next #
#########################################

exit
:WIN
@ECHO off
REM Check if bash script is present
DIR /b /a-d |find /v "." |find "cx" >nul
if %errorlevel% NEQ 0 (
    docker run --rm --name clx-win-wrapper -v "%cd%/":/root cloudrexx/ubuntu bash -c "cd /root && wget -q https://raw.githubusercontent.com/Cloudrexx/cloudrexx/master/cx && chmod +x cx"
)

SETLOCAL ENABLEEXTENSIONS ENABLEDELAYEDEXPANSION
set string=%cd%

REM Split on first doublepoint to get drive letter separately
for /f "tokens=1 delims=:" %%a in ("%string%") do set new_var=%%a

REM Replace uppercase drive letter by lowercase
call :tolower new_var

REM Merge new path and replace backslashes and colons
set string=%new_var%%string:~2%
set string=%string:\=/%
set string=/host_mnt/%string::/=/%

REM Special case: user wants to start interactive shell to wrapper container
if "%*" == "env shell --wrapper" (
    docker run --rm -ti --name clx-win-wrapper -e PROXY_HOST_DIR="%string%" -v "%cd%/":/root -v /var/run/docker.sock:/var/run/docker.sock cloudrexx/ubuntu sh -c "cd /root && bash"
    goto :EOF
)

REM Pass everything through our wrapper
docker run --rm -ti --name clx-win-wrapper -v "%cd%/":/root -v /var/run/docker.sock:/var/run/docker.sock cloudrexx/ubuntu bash -c "cd /root && ./cx --proxy-host-dir='%string%' %*"
goto :EOF

:tolower
for %%L IN (a b c d e f g h i j k l m n o p q r s t u v w x y z) DO SET %1=!%1:%%L=%%L!
goto :EOF
